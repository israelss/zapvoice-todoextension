var y=Object.defineProperty;var h=(e,t,a)=>t in e?y(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a;var f=(e,t,a)=>(h(e,typeof t!="symbol"?t+"":t,a),a);import{s,t as p,e as v,a as r,r as i,b as T}from"./utils-796181be.js";class l extends Error{constructor({message:a,statusCode:d,error:o}){super(a);f(this,"statusCode");f(this,"error");this.message=a,this.statusCode=d,this.error=o}}const g=e=>({body:JSON.stringify(e),headers:{"Content-Type":"application/json"}});async function c(e,t){const a=await s.getToken(),d={...t,headers:{...t.headers,Authorization:`Bearer ${a}`}};try{const o=await fetch(e,d),E=await o.json();if(o.ok)return{data:E,ok:!0};throw new l(E)}catch(o){return console.log({error:o}),o instanceof l?{message:o.message,ok:!1}:o instanceof TypeError?o.message==="Failed to fetch"?{message:"Erro de rede. Tente novamente mais tarde",ok:!1}:{message:o.message,ok:!1}:{message:"Erro desconhecido",ok:!1}}}async function u(e,t){return await c(e,{method:"POST",...g(t)})}async function _(e,t){let a={method:"PATCH"};return t!==void 0&&(a={...a,...g(t)}),await c(e,a)}async function A(e){return await c(e,{method:"DELETE"})}async function I(e){return await c(e,{method:"GET"})}const S=e=>({login:async function({email:t,password:a}){return await u(`${e}/auth/login`,{email:t,password:a})},register:async function({email:t,password:a}){return await u(`${e}/auth/register`,{email:t,password:a})}}),R=e=>({create:async function({content:t}){return await u(`${e}/items`,{content:t})},getAll:async function(){return await I(`${e}/items`)},markAsComplete:async function({id:t}){return await _(`${e}/items/${t}/complete`)},remove:async function({id:t}){return await A(`${e}/items/${t}`)}}),w="http://localhost:3000",n={auth:S(w),items:R(w)},$=async e=>{const t=await n.auth.login(e);await k(t)},b=async e=>{const t=await n.auth.register(e);await k(t)};async function k(e){if(await s.clear(),e.ok){const{access_token:t,email:a}=e.data;s.setItems({[p]:t,[v]:a})}else s.setError(e.message)}const m=async()=>{await s.remove(r);const e=await n.items.getAll();N(e)},M=async e=>{await s.remove(r),(await n.items.create(e)).ok?m():s.setError("Não foi possível criar a tarefa. Tente novamente mais tarde")},C=async e=>{await s.remove(r),(await n.items.markAsComplete(e)).ok?m():s.setError("Não foi possível marcar a tarefa como completa. Tente novamente mais tarde")},L=async e=>{await s.remove(r),(await n.items.remove(e)).ok?m():s.setError("Não foi possível remover a tarefa. Tente novamente mais tarde")};async function N(e){e.ok?i.sendMessage({type:"GET_ITEMS_RESPONSE",payload:e}):s.setError("Não foi possível carregar as tarefas. Tente novamente mais tarde")}i.onInstalled.addListener(async()=>{if(await s.getToken()!==void 0){const t=await n.items.getAll();t.ok&&T(t.data.filter(a=>!a.completed).length)}});i.onStartup.addListener(async()=>{if(await s.getToken()!==void 0){const t=await n.items.getAll();t.ok&&T(t.data.filter(a=>!a.completed).length)}});i.onMessage.addListener(async({type:e,payload:t})=>{switch(e){case"LOGIN_REQUEST":{await $(t);break}case"REGISTER_REQUEST":{await b(t);break}case"GET_ITEMS_REQUEST":{await m();break}case"CREATE_ITEM_REQUEST":{await M(t);break}case"COMPLETE_ITEM_REQUEST":{await C(t);break}case"REMOVE_ITEM_REQUEST":{await L(t);break}}});
